# 비동기

브라우저 환경에서는 얼마나 걸릴지 예측할 수 없는 요소가 많다. 대표적으로는 사용자 입력 대기와 서버 API 응답, 파일 조회 등이 있다. 이러한 유형의 작업들을 자바스크립트 엔진이 코드를 실행할 때 동기적으로 처리하게 된다면 프로그램을 사용하지도 못하고 **모든 작업이 마무리될 때까지 무한정 대기**하게 된다. 이건 당연하게도 너무 비효율적이다. 자바스크립트가 멀티 스레드의 언어였다면 다른 스레드에 해당 작업을 넘기고, 사용자의 interaction을 할 수 있었겠지만 안타깝게도 자바스크립트는 **싱글 스레드 언어**이다.

이러한 한계를 보완하기 위해 Event Loop가 나타나게 되었다. 해결 방법은 꽤 단순하다. ‘지금’이 아닌 **‘나중에’** 처리하겠다는 전략이다. 나중에 처리하는 코드는 `ajax`, `setTimeout`과 같은 Web API이다.



1. Web API를 실행하면 브라우저 환경에서 해당 작업을 수행한다. [Web API는 어떻게 동작하지?](##Web API)
2. 작업이 완료되면 **callback** 함수를 callback queue에 실행 대기 상태로 넣어준다.
3. 자바스크립트 엔진이 모든 코드를 다 실행해서 call stack이 비게 되면, callback queue에서 순차적으로 하나씩 꺼내어 **‘나중에’** 실행하게 된다.

이걸 이미지로 표현하자면 아래와 같다.
![42eatw03fcha0e1qcrf0](https://github.com/kjhwert/blogs/assets/40383255/496749e8-267e-4e30-b962-f1de18cdf0c7)

해당 이미지에는 callback queue가 microtask queue, macrotask queue 두 가지로 나뉘어져 있지만 이 부분은 이후에 설명하겠다.

# Callback

‘지금’이 아닌 ‘나중에’가 자바스크립트의 비동기 처리 전략이라는 걸 알게 되었다. 나중에 돌아오기 위해 자바스크립트는 callback 함수를 달아서 활용하게 된다. 바로 1세대 비동기 처리 방법인 것이다. 
callback은 비동기를 표현하고 관리하는 가장 기본적이고 일반적인 방법이다. 자바스크립트 개발자는 의도하지 않아도 자연스럽게 callback 패턴을 활용해서 흐름을 제어하곤 한다.
자바스크립트의 함수가 일급 함수인 덕분에 이러한 패턴이 생겨날 수 있었고, 여전히 비동기를 표현하기에 적절하고 유용한 표현이다. 하지만, 비동기의 depth가 깊어지면 생각은 조금 달라진다.

### 가독성
필요한 데이터를 얻기 위해 API 호출을 한다고 가정하자.
하지만 해당 API를 호출하기 위해 필요한 데이터 또한 요청을 통해 얻어야한다고 하면 아래와 같은 형태의 코드가 구성된다.
```typescript
listen("click", function handler(e) {
    ajax("https://some.url.1", (res) => {
        // calculate response data
        const result = calculatedData;
        
        ajax(`https://some.url.2?someData=${result}`, (res) => {
            console.log('활용할 데이터: ', res)  
        })
    })
})
```
조금 가독성이 떨어지기는 하지만, 그래도 아직까지는 이해하기 크게 어렵지 않다.
하지만 현재 코드는 에러를 고려하지 않았다. API 호출이 실패할 수도 있기 때문에 이 부분도 추가해보자.
```typescript
listen("click", function handler(e) {
    ajax("https://some.url.1", (res) => {
        // calculate response data
        const result = calculatedData;
        
        ajax(`https://some.url.2?someData=${result}`, (res) => {
            console.log('활용할 데이터: ', res)
        }, (err) => {
            console.error('https://some.url.2', err)
        })
    }, (err) => {
        console.error('https://some.url.1', err)
    })
})
```
에러를 분할 콜백으로 제공한다고 했을 때 에러 우선 콜백보다는 그나마 낫지만 이조차도 머리가 조금씩 어지러워진다.
이 상황에서 또 다른 API가 추가된다고 하면 자연스럽게 함수를 나누려는 시도를 하게 된다.
```typescript
listen("click", function handler(e) {
    someUrl1((res1) => someUrl2(res1, (res2) => someUrl3(res2, (res3) => {
        console.log('내가 필요한 데이터: ', res3)
    })))
})

function someUrl1(callback) {
    ajax("https://some.url.1", (res) => {
        // calculate response data
        const result = calculatedData;
        callback(result)
    }, (err) => {
        console.error('https://some.url.1', err)
    })
}

function someUrl2(params, callback) {
    ajax(`https://some.url.2?someData=${params}`, (res) => {
        // calculate response data
        const result = calculatedData;
        callback(result)
    }, (err) => {
        console.error('https://some.url.2', err)
    })
}

function someUrl3(params, callback) {
    ajax(`https://some.url.3?someData=${params}`, (res) => {
        // calculate response data
        const result = calculatedData;
        callback(result)
    }, (err) => {
        console.error('https://some.url.2', err)
    })
}
```
someUrl1 -> someUrl2 -> someUrl3 함수를 호출하면서 결국 원하는 데이터를 얻긴했지만
각 함수에서는 어떤 처리를 하는지 확인하기 위해서는 에디터를 이리저리 옮겨가며 확인해야 한다. 코드에 익숙치 않다면
이 흐름을 파악하고 따라가는 데에 더 많은 어려움을 겪을 것이다. 정리하자면, 콜백을 통한 비동기 처리는
비동기의 흐름을 **비선형적, 비순차적인 방향**으로 나타내기 때문에 코드를 이해하기 어렵다.

### 제어의 역전
읽어볼 것 [링크](https://dailylearn.hashnode.dev/callback-hell-and-inversion-of-control)

# Promise


콜백은 제어의 역전이라고 했는데, 프라미스를 통해 다시 제어권을 획득하게 되었다.
Promise는 귀결되고나면 외부적으로 불변상태이므로 변경될 일은 없다. 이 말은 promise의 상태가 resolved 혹은 rejected로 귀결되고 나면 다른 상태로 바뀔 일이 없다는 말이다.
```typescript
new Promise((resolve, reject) => {
    resolve('완료')
    
    reject('완료 아닌데?') // 무시됨
    resolve('데이터 바꿀건데?') // 무시됨
})
```
1. 
2. 


궁금한 부분
1. 프라미스는 귀결되고 나면 외부적으로 불변 상태이므로 사고로 또는 악의적으로 변경되는 일은 없다. 어떻게?
2. 프라미스를 구현한 방법? 어떻게 구현했을까..? → thenable duck typing. 데너블에 해당하는 값은 무조건 프라미스 규격에 맞다고 간주하는 것.

# ETC

## Web API

---

You Don’t Know JS [this와 객체 프로토타입, 비동기와 성능]
https://ko.javascript.info/callbacks
https://ko.javascript.info/promise-basics
https://ko.javascript.info/event-loop
[https://inpa.tistory.com/entry/🌐-js-async](https://inpa.tistory.com/entry/%F0%9F%8C%90-js-async)
https://www.youtube.com/watch?v=8aGhZQkoFbQ
