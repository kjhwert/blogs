# 비동기

브라우저 환경에서는 얼마나 걸릴지 예측할 수 없는 요소가 많다. 대표적으로는 사용자 입력 대기와 서버 API 응답, 파일 조회 등이 있다. 이러한 유형의 작업들을 자바스크립트 엔진이 코드를 실행할 때 동기적으로 처리하게 된다면 프로그램을 사용하지도 못하고 **모든 작업이 마무리될 때까지 무한정 대기**하게 된다. 이건 당연하게도 너무 비효율적이다. 자바스크립트가 멀티 스레드의 언어였다면 다른 스레드에 해당 작업을 넘기고, 사용자의 interaction을 할 수 있었겠지만 안타깝게도 자바스크립트는 **싱글 스레드 언어**이다.

이러한 한계를 보완하기 위해 Event Loop가 나타나게 되었다. 해결 방법은 꽤 단순하다. ‘지금’이 아닌 **‘나중에’** 처리하겠다는 전략이다. 나중에 처리하는 코드는 `ajax`, `setTimeout`과 같은 Web API이다.



1. Web API를 실행하면 브라우저 환경에서 해당 작업을 수행한다. [그럼 Web API는 어떻게 실행되지?](https://www.notion.so/bc1239c0e08e434b8f445d1e2de07eb0?pvs=21)
2. 작업이 완료되면 **callback** 함수를 callback queue에 실행 대기 상태로 넣어준다.
3. 자바스크립트 엔진이 모든 코드를 다 실행해서 call stack이 비게 되면, callback queue에서 순차적으로 하나씩 꺼내어 **‘나중에’** 실행하게 된다.

이걸 이미지로 표현하자면 아래와 같다.

![](../../../../Downloads/42eatw03fcha0e1qcrf0.gif)

해당 이미지에는 callback queue가 microtask queue, macrotask queue 두 가지로 나뉘어져 있지만 이 부분은 이후에 설명하겠다.

# Callback

‘지금’이 아닌 ‘나중에’가 자바스크립트의 비동기 처리 전략이라는 걸 알게 되었다. 나중에 돌아오기 위해 자바스크립트는 callback 함수를 달아서 활용하게 된다. 바로 1세대 비동기 처리 방법인 것이다.

# Promise

1. 프라미스는 귀결되고 나면 외부적으로 불변 상태이므로 사고로 또는 악의적으로 변경되는 일은 없다. 어떻게?
2. 프라미스를 구현한 방법? 어떻게 구현했을까..? → thenable duck typing. 데너블에 해당하는 값은 무조건 프라미스 규격에 맞다고 간주하는 것.

# ETC

## How Web API works?

---

You Don’t Know JS [this와 객체 프로토타입, 비동기와 성능]

https://ko.javascript.info/event-loop

[https://inpa.tistory.com/entry/🌐-js-async](https://inpa.tistory.com/entry/%F0%9F%8C%90-js-async)

https://www.youtube.com/watch?v=8aGhZQkoFbQ
